<!doctype html>
<html>
<title>CG Project - LG, CP, MC</title>
<body>
<canvas width = "570" height = "570" id = "my_Canvas"></canvas>
<br>

Tesselation Level (<b id="tessval"></b>): <input type="range" id="myRange" value="7"  min="0" max="8" oninput="setTess(ptype);">

<br>
<form action="">
Triangles: <input type="radio" name="prim" onchange="ptype=gl.TRIANGLES; setTess(ptype);" checked="checked">
Lines: <input type="radio" name="prim" onchange="ptype=gl.LINES; setTess(ptype);">
Line Loop: <input type="radio" name="prim" onchange="ptype=gl.LINE_LOOP; setTess(ptype);">
Line Strip: <input type="radio" name="prim" onchange="ptype=gl.LINE_STRIP; setTess(ptype);">
</form>

<script>

    /*============== Creating a canvas ====================*/
    var canvas = document.getElementById('my_Canvas');
    gl = canvas.getContext('experimental-webgl');


    var vertices = [];
    var indices = [];

    //Main Tesselation Function
    //tess ( level of tesselation, base length per triangle, x and y offset from top left)
    function tess(level,dist,offx,offy){

        //Get Number of Edge vertices
        var num= Math.pow(2,level)+1;

        console.log("Tesselation Level: "+level);
        console.log("Edge Vertices: "+num);

        //Initialize vertice array
        vertices = [];

        //Vertice Generation Loop
        var x;
        var y;
        for(y=0;y<num;y++) {
            for (x = 0; x < num * 3; x++) {
               // console.log("x "+x+ " y "+y)
                //Get X val
                vertices[x +y*num*3] = -1.0+offx+(x/3)*(dist*2)/(num-1);
                //Get Y val
                vertices[x + 1 +y*num*3  ] = 1.0-offy-(y)*(dist*2)/(num-1);
                //Get Z val (zero for uniform plane)
                vertices[x + 2 +y*num*3 ] = 0;
                x += 2;

            }
        }


        //console.table(vertices.toString())

        //Indices
         indices = [];
        //Ver used for indices index
        var ver=0;
        for(y=0;y<(num-1);y++) {
            for (x = 0; x < (num - 1) * 3; x++) {

                //Get X
                indices[x + y * (num-1) * 3] = ver+y;
                //Get Y
                indices[x + 1 + y * (num-1) * 3] = ver + 1+y;
                //Get Z
                indices[x + 2 + y * (num-1) * 3] = ver + num+y;
                x += 2;
                ver++;
            }

        }

       // console.table(indices.toString())


        console.log("Total Vertices: "+vertices.length/3);
        console.log("Indices: "+indices.length);
        console.log("");

    }


    //tess(0,0.5);
    //draw(gl.LINES);

    //document.getElementById("tessval").innerHTML = 0;


    function setTess(ptype) {
        var x = document.getElementById("myRange").value;
        var ox;
        var oy;
        document.getElementById("tessval").innerHTML = x;

        tess(x,0.7,0.3,0.3);
        draw(ptype);
        }


    setInterval("draw(ptype);", 40);

    ptype=gl.TRIANGLES;
    setTess(ptype);

    //tess(1,1.0);

    // Gets a transformation matrix given the rotation angles
    function getTransformationMatrix(rx, ry, rz)
    {
        // Pre-computes trigonometric values (mainly for better readability)
        var cx = Math.cos(rx), sx = Math.sin(rx);
        var cy = Math.cos(ry), sy = Math.sin(ry);
        var cz = Math.cos(rz), sz = Math.sin(rz);

        // Returns matrix
        return new Float32Array([cy*cz, (sx*sy*cz-cx*sz), (sx*sz+cx*sy*cz), 0,
            cy*sz, (sx*sy*sz+cx*cz), (cx*sy*sz-sx*cz), 0,
            -sy,   sx*cy,            cx*cy,            0,
            0,     0,                0,                1]);
    }




    var startTime = new Date().getTime();


    function draw(ptype) {

        // Create an empty buffer object to store vertex buffer
        var vertex_buffer = gl.createBuffer();

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Pass the vertex data to the buffer
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Create an empty buffer object to store Index buffer
        var Index_Buffer = gl.createBuffer();

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Pass the vertex data to the buffer
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Unbind the buffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        /*================ Shaders ====================*/

        // Vertex shader source code
        var vertCode =
            'attribute vec3 coordinates;' +
            'uniform mat4 mvp;'+
            'uniform float time;'+
            'void main(void) {' +
            ' gl_Position = mvp * vec4(coordinates[0],coordinates[1],0.2*sin(coordinates[0]*7.5*sin(time)*3.14), 1.0);' +
            '}';



        // Create a vertex shader object
        var vertShader = gl.createShader(gl.VERTEX_SHADER);

        // Attach vertex shader source code
        gl.shaderSource(vertShader, vertCode);

        // Compile the vertex shader
        gl.compileShader(vertShader);

        //fragment shader source code
        var fragCode =
            'void main(void) {' +
            ' gl_FragColor = vec4(0.2, 0.5, 1.0, 1.0);' +
            '}';

        // Create fragment shader object
        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Attach fragment shader source code
        gl.shaderSource(fragShader, fragCode);

        // Compile the fragmentt shader
        gl.compileShader(fragShader);

        // Create a shader program object to store
        // the combined shader program
        var shaderProgram = gl.createProgram();


        // Attach a vertex shader
        gl.attachShader(shaderProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(shaderProgram, fragShader);

        // Link both the programs
        gl.linkProgram(shaderProgram);

        var timeNow =(new Date().getTime() -startTime)/1000;


       // console.log(timeNow);


        // Use the combined shader program object
        gl.useProgram(shaderProgram);
        gl.uniform1f( gl.getUniformLocation( shaderProgram, 'time' ), timeNow );

        /*======= Associating shaders to buffer objects =======*/

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Bind index buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Get the attribute location
        var coord = gl.getAttribLocation(shaderProgram, "coordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

        // Enable the attribute
        gl.enableVertexAttribArray(coord);

        /*=========Drawing the triangle===========*/

        var ax=-80; ///70
        var ay =0;
        var az=20; ///50

        ax *= -2*Math.PI/360; ay *= -2*Math.PI/360; az *= -2*Math.PI/360;
        var amvp = gl.getUniformLocation(shaderProgram, "mvp");
        var mat = getTransformationMatrix(ax, ay, az);



        gl.uniformMatrix4fv(amvp, false, mat);

        // Clear the canvas
        gl.clearColor(0.5, 0.5, 0.5, 0.9);

        // Enable the depth test
        gl.enable(gl.DEPTH_TEST);

        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Set the view port
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Draw the triangle
        gl.drawElements(ptype, indices.length, gl.UNSIGNED_SHORT, 0);

    }
    //GL TYPES
    // POINTS, LINE_STRIP, LINE_LOOP, LINES,
    // TRIANGLE_STRIP,TRIANGLE_FAN, TRIANGLES

</script>

</body>
</html>