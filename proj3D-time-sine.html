<!doctype html>
<html>
<title>CG Project - LG, CP, MC</title>
<body>
<canvas width = "1024" height = "600" id = "my_Canvas"></canvas>
<br>

Tesselation Level (<b id="tessval"></b>): <input type="range" id="myRange" value="5"  min="0" max="8" oninput="setTess(ptype);">

<br>
<form action="">
Triangles: <input type="radio" name="prim" onchange="ptype=gl.TRIANGLES; setTess(ptype);" checked="checked">
Lines: <input type="radio" name="prim" onchange="ptype=gl.LINES; setTess(ptype);">
Line Loop: <input type="radio" name="prim" onchange="ptype=gl.LINE_LOOP; setTess(ptype);">
Line Strip: <input type="radio" name="prim" onchange="ptype=gl.LINE_STRIP; setTess(ptype);">
</form>
Rotate Camera with < Up,Down,Left,Right >

<script id="wave-vertex" type="x-shader/x-vertex" >
    precision mediump float;

    attribute vec3 coordinates;
    uniform mat4 mvp;
    uniform float time;
    uniform int numWaves;
    uniform float amplitudeList[50];
    uniform float steepnessList[50];
    uniform float phaseConstantList[50];
    uniform float wList[50];
    uniform vec2 dirList[50];

    varying vec3 vCoord;
    varying vec3 fPosition;
    varying vec3 fNormal;

    varying mat3 invTBN;

    void main(void)
    {
        float x = coordinates[0];
        float origx = x;
        float y = coordinates[1];
        float origy = y;
        float z = coordinates[2];

        vec3 B = vec3(1, 0, 0);
        vec3 T = vec3(0, 1, 0);
        vec3 N = vec3(0, 0, 1);

        for(int i = 0; i < 5000; i++)
        {
            if(i >= numWaves)
                break;

            // TBN Math
            float wa = wList[i] * amplitudeList[i];
            float s = sin(wList[i] * dot(dirList[i], coordinates.xy) + phaseConstantList[i] * time);
            float c = cos(wList[i] * dot(dirList[i], coordinates.xy) + phaseConstantList[i] * time);

            // Bitangent
            float bxchange = -(steepnessList[i] * dirList[i].x * dirList[i].x * wa * s);
            float bychange = -(steepnessList[i] * dirList[i].x * dirList[i].y * wa * s);
            float bzchange = dirList[i].x * wa * c;
            B = vec3(B.x + bxchange, B.y + bychange, B.z + bzchange);

            // Tangent
            float txchange = bychange; // Equivalent per GPU Gems
            float tychange = -(steepnessList[i] * dirList[i].y * dirList[i].y * wa * s);
            float tzchange = bzchange;
            T = vec3(T.x + txchange, T.y + tychange, T.z + tzchange);

            // Normal
            float nxchange = -(dirList[i].x * wa * c);
            float nychange = -(dirList[i].y * wa * c);
            float nzchange = -(steepnessList[i] * wa * s);
            N = vec3(N.x + nxchange, N.y + nychange, N.z + nzchange);

            // Position Math
            x = x + steepnessList[i] * amplitudeList[i] * dirList[i][0] * cos(dot(wList[i] * dirList[i].xy, vec2(origx, origy).xy) + phaseConstantList[i] * time);
            y = y + steepnessList[i] * amplitudeList[i] * dirList[i][1] * cos(dot(wList[i] * dirList[i].xy, vec2(origx, origy).xy) + phaseConstantList[i] * time);
            z = z + amplitudeList[i] * sin(dot(wList[i] * dirList[i].xy, vec2(origx, origy).xy) + phaseConstantList[i] * time);
        }

        // Normalize final vectors
        mat3 mvp3x3 = mat3(mvp);
        T = mvp3x3 * normalize(T);
        N = mvp3x3 * normalize(N);
        B = mvp3x3 * normalize(B);

        // Construct invTBN
        invTBN = mat3(
            vec3(T.x, B.x, N.x),
            vec3(T.y, B.y, N.y),
            vec3(T.z, B.z, N.z));

        // Pass through new normal and position
        fPosition = mvp3x3 * vec3(x, y, z);
        fNormal = N;

        // Extraneous: toremove
        vCoord = coordinates;
        gl_Position = mvp * vec4(x, y, z, 1.0);
    }
</script>

<script id="wave-fragment" type="x-shader/x-fragment" >
    precision mediump float;
    varying vec3 vCoord;

    varying vec3 fPosition;
    varying vec3 fNormal;
    varying mat3 invTBN;

    void main(void)
    {
        // TODO: move things to TBN space to do lighting

        gl_FragColor = vec4(vCoord[0]*1.5, vCoord[1], 0.5, 1.0);
    }
</script>

<script>
    function getShader(gl, id) {

        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }
        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    /*============== Creating a canvas ====================*/
    var canvas = document.getElementById('my_Canvas');
    gl = canvas.getContext('experimental-webgl');


    var vertices = [];
    var indices = [];

    //Main Tesselation Function
    //tess ( level of tesselation, base length per triangle, x and y offset from top left)
    function tess(level,dist,offx,offy){

        //Get Number of Edge vertices
        var num= Math.pow(2,level)+1;

        console.log("Tesselation Level: "+level);
        console.log("Edge Vertices: "+num);

        //Initialize vertice array
        vertices = [];

        //Vertice Generation Loop
        var x;
        var y;
        for(y=0;y<num;y++) {
            for (x = 0; x < num * 3; x++) {
               // console.log("x "+x+ " y "+y)
                //Get X val
                vertices[x +y*num*3] = -1.0+offx+(x/3)*(dist*2)/(num-1);
                //Get Y val
                vertices[x + 1 +y*num*3  ] = 1.0-offy-(y)*(dist*2)/(num-1);
                //Get Z val (zero for uniform plane)
                vertices[x + 2 +y*num*3 ] = -0.6;
                x += 2;

            }
        }


        //console.table(vertices.toString())

        //Indices
         indices = [];
        //Ver used for indices index
        var ver=0;
        for(y=0;y<(num-1);y++) {
            for (x = 0; x < (num - 1) * 3; x++) {

                //Get X
                indices[x + y * (num-1) * 3] = ver+y;
                //Get Y
                indices[x + 1 + y * (num-1) * 3] = ver + 1+y;
                //Get Z
                indices[x + 2 + y * (num-1) * 3] = ver + num+y;
                x += 2;
                ver++;
            }

        }

       // console.table(indices.toString())


        console.log("Total Vertices: "+vertices.length/3);
        console.log("Indices: "+indices.length);
        console.log("");

    }


    //tess(0,0.5);
    //draw(gl.LINES);

    //document.getElementById("tessval").innerHTML = 0;


    function setTess(ptype) {
        var x = document.getElementById("myRange").value;
        var ox;
        var oy;
        document.getElementById("tessval").innerHTML = x;

        tess(x,1.0,0.0,0.0);
        draw(ptype);
        }


    setInterval("draw(ptype);", 40);
    document.onkeydown = handleKeyDown;


    ptype=gl.TRIANGLES;
    setTess(ptype);

    //tess(1,1.0);

    // Gets a transformation matrix given the rotation angles
    function getTransformationMatrix(rx, ry, rz)
    {
        // Pre-computes trigonometric values (mainly for better readability)
        var cx = Math.cos(rx), sx = Math.sin(rx);
        var cy = Math.cos(ry), sy = Math.sin(ry);
        var cz = Math.cos(rz), sz = Math.sin(rz);

        // Returns matrix
        return new Float32Array([cy*cz, (sx*sy*cz-cx*sz), (sx*sz+cx*sy*cz), 0,
            cy*sz, (sx*sy*sz+cx*cz), (cx*sy*sz-sx*cz), 0,
            -sy,   sx*cy,            cx*cy,            0,
            0,     0,                0,                1]);
    }




    var startTime = new Date().getTime();




    // Wave Parameter Functions
    function generateWaves(count)
    {
        numWaves = count;
        steepnessList = [];
        amplitudeList = [];
        dirList = [];
        phaseConstantList = [];

        for(var i = 0; i < count; i++)
        {

        }
    }

    // Wave Parameter Bounds
    var steepnessMin = 0.0;
    var steepnessMax = 0.8;
    var amplitudeMin = 0.01;
    var amplitudeMax = 1.0;
    var phaseConstMin = 1.0;
    var phaseConstMax = 2.0;

    // Generated Wave Parameters
    var numWaves = 3;
    var steepnessList = [0.159, 0.51, 0.159];
    var amplitudeList = [0.1, 0.05, 0.1];
    var dirList = [1, 0, 0, 1, -1, 1];
    var phaseConstantList = [8.169, 5.2, 8.12];
    var wList = [9.28, 2.48, 7.2];




    var ax=-110; ///70
    var ay =0;
    var az=20; ///50
    function handleKeyDown(event) {

        if (event.keyCode == 37) {
            //Left Arrow Key
            az+=-5*-2*Math.PI/360;
        } else if (event.keyCode == 38) {
            //Up Arrow Key
            ax+=5*-2*Math.PI/360;
        } else if (event.keyCode == 39) {
            //Right Arrow Key
            az+=5*-2*Math.PI/360;
        } else if (event.keyCode == 40) {
            //Down Arrow Key
            ax+=-5*-2*Math.PI/360;

        }
        //ax *= -2*Math.PI/360; ay *= -2*Math.PI/360; az *= -2*Math.PI/360;
    }

    //Proj matrix convert
    ax *= -2*Math.PI/360; ay *= -2*Math.PI/360; az *= -2*Math.PI/360;



    function draw(ptype) {

        // Create an empty buffer object to store vertex buffer
        var vertex_buffer = gl.createBuffer();

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Pass the vertex data to the buffer
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Create an empty buffer object to store Index buffer
        var Index_Buffer = gl.createBuffer();

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Pass the vertex data to the buffer
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Unbind the buffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        /*================ Shaders ====================*/
        var vertShader = getShader(gl, "wave-vertex");
        var fragShader = getShader(gl, "wave-fragment");

        var shaderProgram = gl.createProgram();

        // Attach a vertex shader
        gl.attachShader(shaderProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(shaderProgram, fragShader);

        // Link both the programs
        gl.linkProgram(shaderProgram);

        var timeNow =(new Date().getTime() -startTime)/1000;


       //console.log(timeNow);


        // Use the combined shader program object
        gl.useProgram(shaderProgram);
        gl.uniform1f(gl.getUniformLocation( shaderProgram, 'time' ), timeNow);

        /*======= Associating shaders to buffer objects =======*/

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Bind index buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Get the attribute location
        var coord = gl.getAttribLocation(shaderProgram, "coordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

        // Enable the attribute
        gl.enableVertexAttribArray(coord);


        var amvp = gl.getUniformLocation(shaderProgram, "mvp");
        var mat = getTransformationMatrix(ax, ay, az);


        gl.uniformMatrix4fv(amvp, false, mat);

        // Wave Parameters
        gl.uniform1i(gl.getUniformLocation(shaderProgram, "numWaves"), numWaves);
        gl.uniform1fv(gl.getUniformLocation(shaderProgram, "amplitudeList"), new Float32Array(amplitudeList));
        gl.uniform1fv(gl.getUniformLocation(shaderProgram, "steepnessList"), new Float32Array(steepnessList));
        gl.uniform1fv(gl.getUniformLocation(shaderProgram, "phaseConstantList"), new Float32Array(phaseConstantList));
        gl.uniform2fv(gl.getUniformLocation(shaderProgram, "dirList"), new Float32Array(dirList));
        gl.uniform1fv(gl.getUniformLocation(shaderProgram, "wList"), new Float32Array(wList));

        // Clear the canvas
        gl.clearColor(0.5, 0.5, 0.5, 0.9);

        // Enable the depth test
        gl.enable(gl.DEPTH_TEST);

        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Set the view port
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Draw the triangle
        gl.drawElements(ptype, indices.length, gl.UNSIGNED_SHORT, 0);

    }
    //GL TYPES
    // POINTS, LINE_STRIP, LINE_LOOP, LINES,
    // TRIANGLE_STRIP,TRIANGLE_FAN, TRIANGLES

</script>

</body>
</html>